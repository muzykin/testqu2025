<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Functions - Advanced</title>

		<meta name="description" content="Functions - Advanced">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="stylesheet" href="../../common/css/reveal.min.css">
    <link rel="stylesheet" href="../../common/css/gdilight.css" id="theme">

    <!-- For syntax highlighting -->
    <!-- dark editor -->
    <link rel="stylesheet" href="../../common/css/editor/dark.css">

    <!-- If use the PDF print sheet so students can print slides-->

    <link rel="stylesheet" href="../../common/css/print/pdf.css" type="text/css" media="print">
		<!--[if lt IE 9]>
		<script src="../../common/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

		        <!-- Opening -->
                <section>
                    <h1 class="center">Functions - Advanced</h2>
                </section>
                <section> 
                  <h2>What we know about Functions?</h2> 
                   <ul>
                     <li>What is a Function</li>
                     <li>How to define and declare Functions</li>
                     <li>Contructing a Funtion</li>
                     <li>Calling a function</li>
                     <li>Adding arguments to a function</li>
                     <li>And more..</li>
                   </ul> 
             
                  </section>

                <section>
                    <h2>Arrow Functions</h2>
                    <p>Arrow functions allows a short syntax for writing function expressions.</p>
                    <p>You don't need the function keyword, the return keyword, and the curly brackets.</p>
<pre><code class ="javascript">
// ES5
var x = function(x, y) {
  return x * y;
}

// ES6
const x = (x, y) => x * y;
</code></pre>

                    <p>You can only omit the return keyword and the curly brackets if the function is a single statement. Because of this, it might be a good habit to always keep them:</p>
                    
<pre><code class ="javascript">
const x = (x, y) => { return x * y };
</code></pre>
                </section>

                <section>
                    <h2>Parameters and Arguments</h2>
                      <p>Function parameters are the names listed in the function definition.</p>
                      <p>Function arguments are the real values passed to (and received by) the function.</p>
<pre><code class ="javascript">
function functionName(parameter1, parameter2, parameter3) {
  // code to be executed
}

x = functionName(agrument1, argument2, argument3)
</code></pre>
<p>If a function is called with missing arguments (less than declared), the missing values are set to undefined</p>

                </section>

                <section>
                    <h2>Default Parameter Values</h2>
                    <p>function parameters can have have default values.</p>
<pre><code class ="javascript" style="max-height: initial">
function myFunction(x, y = 10) {
  return x + y;
}
myFunction(5);
</code></pre>
                </section>

                <section>
                    <h2>Function Rest Parameter</h2>
                    <p>The rest parameter (...) allows a function to treat an indefinite number of arguments as an array:</p>

<pre><code class ="javascript" style="max-height: initial">
function sum(...args) {
  let sum = 0;
  for (let arg of args) sum += arg;
  return sum;
}

let x = sum(4, 9, 16, 25, 29, 100, 66, 77);
</code></pre>

                </section>

                <section>
                    <h2>The Arguments Object</h2>
                    <p>JavaScript functions have a built-in object called the arguments object.</p>
                    <p>The argument object contains an array of the arguments used when the function was called (invoked).</p>
<pre><code class ="javascript">
x = findMax(1, 123, 500, 115, 44, 88);

function findMax() {
  let max = -Infinity;
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] > max) {
      max = arguments[i];
    }
  }
  return max;
}
</code></pre>
                </section>

                <section>
                    <h2>The JavaScript call() Method</h2>
                    <p>The call() method is a predefined JavaScript method.</p>
                    <p>With call(), an object can use a method belonging to another object.</p>

<pre><code class ="javascript">
const person = {
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
}
const person1 = {
  firstName:"John",
  lastName: "Doe"
}
const person2 = {
  firstName:"Mary",
  lastName: "Doe"
}

// This will return "John Doe":
person.fullName.call(person1);
</code></pre>
                </section>

                <section>
                  <h2>The JavaScript apply() Method</h2>
                  <p>The apply() method is similar to the call() method </p>
                  <p>The apply() method accepts arguments in an array:</p>

<pre><code class ="javascript">
const person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + 
      "," + city + "," + country;
  }
}

const person1 = {
  firstName:"John",
  lastName: "Doe"
}

person.fullName.apply(person1, ["Oslo", "Norway"]);
</code></pre>
              </section>

              <section>
                <h2>The JavaScript bind() Method</h2>
                <p>With the bind() method, an object can borrow a method from another object.</p>

<pre><code class ="javascript">
const person = {
  firstName:"John",
  lastName: "Doe",
  fullName: function () {
    return this.firstName + " " + this.lastName;
  }
}

const member = {
  firstName:"Hege",
  lastName: "Nilsen",
}

let fullName = person.fullName.bind(member);
</code></pre>
            </section>
            <section>
              <h2>Function Sequence</h2>
              <p>JavaScript functions are executed in the sequence they are called. Not in the sequence they are defined.</p>

<pre><code class ="javascript">
function myDisplayer(some) {
  document.getElementById("demo").innerHTML = some;
}

function myFirst() {
  myDisplayer("Hello");
}

function mySecond() {
  myDisplayer("Goodbye");
}

myFirst();
mySecond();
</code></pre>
          </section>
          <section>
            <h2>Sequence Control</h2>
            <p>Sometimes you would like to have better control over when to execute a function.</p>

<pre><code class ="javascript">
function myDisplayer(some) {
  document.getElementById("demo").innerHTML = some;
}

function myCalculator(num1, num2) {
  let sum = num1 + num2;
  return sum;
}

let result = myCalculator(5, 5);
myDisplayer(result);
</code></pre>
<p>The problem with the example above, is that you have to call two functions to display the result.</p>
        </section>
        <section>
          <h2>JavaScript Callbacks</h2>
          <p>A callback is a function passed as an argument to another function.</p>

<pre><code class ="javascript">
function myDisplayer(some) {
  document.getElementById("demo").innerHTML = some;
}

function myCalculator(num1, num2, myCallback) {
  let sum = num1 + num2;
  myCallback(sum);
}

myCalculator(5, 5, myDisplayer);
</code></pre>
<p>When you pass a function as an argument, remember not to use parenthesis.</p>
      </section>
      <section>
        <h2>JavaScript Promises</h2>
        <p>A JavaScript Promise object contains both the producing code and calls to the consuming code:</p>

<pre><code class ="javascript">
let myPromise = new Promise(function(myResolve, myReject) {
// "Producing Code" (May take some time)

  myResolve(); // when successful
  myReject();  // when error
});

// "Consuming Code" (Must wait for a fulfilled Promise)
myPromise.then(
  function(value) { /* code if successful */ },
  function(error) { /* code if some error */ }
);
</code></pre>
<p>When the producing code obtains the result, it should call one of the two callbacks.</p>
    </section>
    <section>
      <h3>Promise - How To</h3>
      <p>Promise.then() takes two arguments, a callback for success and another for failure.

        Both are optional, so you can add a callback for success or failure only.</p>

<pre><code class ="javascript">
function myDisplayer(some) {
  document.getElementById("demo").innerHTML = some;
}

let myPromise = new Promise(function(myResolve, myReject) {
  let x = 0;

// The producing code (this may take some time)

  if (x == 0) {
    myResolve("OK");
  } else {
    myReject("Error");
  }
});

myPromise.then(
  function(value) {myDisplayer(value);},
  function(error) {myDisplayer(error);}
);
</code></pre>
  </section>
  <section>
    <h2>JavaScript Async</h2>
    <p>The keyword async before a function makes the function return a promise:</p>

<pre><code class ="javascript">
async function myFunction() {
  return "Hello";
}
myFunction().then(
  function(value) {myDisplayer(value);}
);
</code></pre>
    <p>Since you expect a normal value (a normal response, not an error)</p>
  </section>
  <section>
    <h2>Await Syntax</h2>
    <p>The await keyword can only be used inside an async function.
      The await keyword makes the function pause the execution and wait for a resolved promise before it continues:</p>

<pre><code class ="javascript">
async function myDisplay() {
  let myPromise = new Promise(function(resolve, reject) {
    resolve("I love You !!");
  });
  document.getElementById("demo").innerHTML = await myPromise;
}

myDisplay();
</code></pre>
</section>

<section>
  <h2>Await-Async Example</h2>
  <p>async and await make promises easier to write</p>

<pre><code class ="javascript">
async function myDisplay() {
  let myPromise = new Promise(function(resolve) {
    setTimeout(function() {resolve("I love You !!");}, 3000);
  });
  document.getElementById("demo").innerHTML = await myPromise;
}

myDisplay();
</code></pre>
    <p>The two arguments (resolve and reject) are pre-defined by JavaScript.
      We will not create them, but call one of them when the executor function is ready.
      Very often we will not need a reject function.</p>
  </section>


     <section>
      <h2>Questions?</h2> 
      
      <p><a href="../../index.html">Return to Table of Contents</a></p>
      
     </section>


			</div>
		</div>


		<script src="../../common/lib/js/head.min.js"></script>
		<script src="../../common/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: '../../common/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../../common/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../../common/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../../common/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../../common/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: '../../common/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
